<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kaarigar3D - Functional</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background: #f5f5f5;
            color: #333;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background: #2c3e50;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 16px;
            z-index: 100;
        }

        .app-title {
            font-size: 18px;
            font-weight: 600;
        }

        .menu-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
        }

        /* Main Content */
        .main-content {
            position: fixed;
            top: 56px;
            bottom: 72px;
            left: 0;
            right: 0;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .active-tool {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        /* Toolbar */
        .toolbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 72px;
            background: white;
            border-top: 1px solid #ddd;
            overflow-x: auto;
            white-space: nowrap;
            padding: 8px;
            z-index: 100;
        }

        .tool-group {
            display: inline-block;
            margin-right: 16px;
        }

        .tool-btn {
            width: 56px;
            height: 56px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .tool-btn.active {
            border-color: #3498db;
            color: #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 200;
            display: none;
        }

        .context-item {
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
        }

        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 56px;
            right: -280px;
            bottom: 72px;
            width: 280px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 16px;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 150;
        }

        .side-panel.open {
            transform: translateX(-280px);
        }

        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            margin: 4px;
            display: inline-block;
            border: 2px solid transparent;
        }

        .color-option.selected {
            border-color: #3498db;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="app-title">Kaarigar3D</div>
        <button class="menu-btn" id="menuBtn">‚ãÆ</button>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div id="canvas-container"></div>
        <div class="active-tool" id="activeTool">Select a tool</div>
        
        <!-- Context Menu -->
        <div class="context-menu" id="contextMenu">
            <div class="context-item" data-action="group">Group</div>
            <div class="context-item" data-action="ungroup">Ungroup</div>
            <div class="context-item" data-action="hide">Hide</div>
            <div class="context-item" data-action="unhide">Unhide</div>
            <div class="context-item" data-action="component">Convert to Component</div>
            <div class="context-item" data-action="explode">Explode</div>
            <div class="context-item" data-action="delete">Delete</div>
        </div>
        
        <!-- Side Panel -->
        <div class="side-panel" id="sidePanel">
            <h3>Material</h3>
            <div>
                <div class="color-option selected" style="background:#cccccc;" data-color="#cccccc"></div>
                <div class="color-option" style="background:#8B4513;" data-color="#8B4513"></div>
                <div class="color-option" style="background:#A0522D;" data-color="#A0522D"></div>
                <div class="color-option" style="background:#D2B48C;" data-color="#D2B48C"></div>
            </div>
            
            <h3 style="margin-top:20px;">Units</h3>
            <div>
                <button class="tool-btn active" data-unit="mm">mm</button>
                <button class="tool-btn" data-unit="cm">cm</button>
                <button class="tool-btn" data-unit="in">inch</button>
                <button class="tool-btn" data-unit="ft">feet</button>
            </div>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <!-- Draw Tools -->
        <div class="tool-group">
            <div class="tool-btn" data-tool="line">
                <span>üìè</span>
                <span>Line</span>
            </div>
            <div class="tool-btn" data-tool="rectangle">
                <span>‚¨õ</span>
                <span>Rect</span>
            </div>
            <div class="tool-btn" data-tool="circle">
                <span>‚ö™</span>
                <span>Circle</span>
            </div>
        </div>
        
        <!-- Modify Tools -->
        <div class="tool-group">
            <div class="tool-btn" data-tool="pushpull">
                <span>‚á≥</span>
                <span>Push/Pull</span>
            </div>
            <div class="tool-btn" data-tool="move">
                <span>‚Üë</span>
                <span>Move</span>
            </div>
            <div class="tool-btn" data-tool="rotate">
                <span>‚Üª</span>
                <span>Rotate</span>
            </div>
        </div>
        
        <!-- Object Tools -->
        <div class="tool-group">
            <div class="tool-btn" data-tool="group">
                <span>üì¶</span>
                <span>Group</span>
            </div>
            <div class="tool-btn" data-tool="ungroup">
                <span>üì¶</span>
                <span>Ungroup</span>
            </div>
            <div class="tool-btn" data-tool="delete">
                <span>üóëÔ∏è</span>
                <span>Delete</span>
            </div>
        </div>
        
        <!-- File Tools -->
        <div class="tool-group">
            <div class="tool-btn" data-tool="save">
                <span>üíæ</span>
                <span>Save</span>
            </div>
            <div class="tool-btn" data-tool="load">
                <span>üìÇ</span>
                <span>Load</span>
            </div>
        </div>
    </div>

    <script>
        // App State
        const state = {
            activeTool: null,
            selectedObject: null,
            selectedFace: null,
            drawing: false,
            tempObject: null,
            startPoint: null,
            unit: 'mm',
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            raycaster: new THREE.Raycaster(),
            pointer: new THREE.Vector2(),
            objects: []
        };

        // DOM Elements
        const menuBtn = document.getElementById('menuBtn');
        const sidePanel = document.getElementById('sidePanel');
        const activeTool = document.getElementById('activeTool');
        const contextMenu = document.getElementById('contextMenu');
        const toolBtns = document.querySelectorAll('.tool-btn[data-tool]');
        const colorOptions = document.querySelectorAll('.color-option');
        const unitBtns = document.querySelectorAll('.tool-btn[data-unit]');

        // Initialize Three.js Scene
        function initScene() {
            // Create scene
            state.scene = new THREE.Scene();
            state.scene.background = new THREE.Color(0xf0f0f0);

            // Create camera
            state.camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 128), 0.1, 1000);
            state.camera.position.set(5, 5, 5);
            state.camera.lookAt(0, 0, 0);

            // Create renderer
            state.renderer = new THREE.WebGLRenderer({ antialias: true });
            state.renderer.setSize(window.innerWidth, window.innerHeight - 128);
            document.getElementById('canvas-container').appendChild(state.renderer.domElement);

            // Add controls
            state.controls = new THREE.OrbitControls(state.camera, state.renderer.domElement);
            state.controls.enableDamping = true;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            state.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            state.scene.add(directionalLight);

            // Add grid helper
            const gridHelper = new THREE.GridHelper(10, 10);
            state.scene.add(gridHelper);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                state.controls.update();
                state.renderer.render(state.scene, state.camera);
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                state.camera.aspect = window.innerWidth / (window.innerHeight - 128);
                state.camera.updateProjectionMatrix();
                state.renderer.setSize(window.innerWidth, window.innerHeight - 128);
            });
        }

        // Tool Functions
        function selectTool(tool) {
            state.activeTool = tool;
            activeTool.textContent = `Active: ${tool}`;
            
            // Update active button
            toolBtns.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tool === tool) {
                    btn.classList.add('active');
                }
            });
        }

        // Object Creation
        function createLine(start, end) {
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const material = new THREE.LineBasicMaterial({ color: 0x000000 });
            const line = new THREE.Line(geometry, material);
            state.scene.add(line);
            state.objects.push(line);
            return line;
        }

        function createRectangle(width, height, position) {
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xcccccc,
                side: THREE.DoubleSide
            });
            const rect = new THREE.Mesh(geometry, material);
            rect.position.copy(position);
            state.scene.add(rect);
            state.objects.push(rect);
            return rect;
        }

        function createCircle(radius, position) {
            const geometry = new THREE.CircleGeometry(radius, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xcccccc,
                side: THREE.DoubleSide
            });
            const circle = new THREE.Mesh(geometry, material);
            circle.position.copy(position);
            state.scene.add(circle);
            state.objects.push(circle);
            return circle;
        }

        // Object Selection
        function getIntersectedObject(event) {
            // Calculate pointer position
            state.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            state.pointer.y = - (event.clientY / (window.innerHeight - 128)) * 2 + 1;
            
            // Update the raycaster
            state.raycaster.setFromCamera(state.pointer, state.camera);
            
            // Check for intersections
            const intersects = state.raycaster.intersectObjects(state.objects);
            
            if (intersects.length > 0) {
                return intersects[0].object;
            }
            return null;
        }

        function handleCanvasClick(event) {
            if (!state.activeTool) return;

            const intersected = getIntersectedObject(event);
            
            // Single click - select object or start drawing
            if (event.detail === 1) {
                if (state.drawing) {
                    // Continue drawing
                    handleDrawing(event);
                } else if (intersected) {
                    // Select object
                    state.selectedObject = intersected;
                    highlightObject(intersected);
                } else {
                    // Start drawing
                    startDrawing(event);
                }
            } 
            // Double click - show context menu
            else if (event.detail === 2 && intersected) {
                showContextMenu(event.clientX, event.clientY, intersected);
            }
        }

        function highlightObject(obj) {
            // Remove previous highlights
            state.scene.children.forEach(child => {
                if (child.userData.isHighlighted) {
                    child.material.emissive.setHex(child.userData.originalEmissive);
                    delete child.userData.isHighlighted;
                }
            });

            // Add highlight to selected object
            if (obj.material && obj.material.emissive) {
                obj.userData.originalEmissive = obj.material.emissive.getHex();
                obj.material.emissive.setHex(0x888888);
                obj.userData.isHighlighted = true;
            }
        }

        // Drawing Functions
        function startDrawing(event) {
            if (!state.activeTool) return;

            state.drawing = true;
            const pos = getCanvasPosition(event);
            state.startPoint = pos;

            switch(state.activeTool) {
                case 'line':
                    state.tempObject = createLine(pos, pos);
                    break;
                case 'rectangle':
                    state.tempObject = createRectangle(0.1, 0.1, pos);
                    break;
                case 'circle':
                    state.tempObject = createCircle(0.1, pos);
                    break;
            }
        }

        function handleDrawing(event) {
            if (!state.drawing || !state.tempObject) return;

            const pos = getCanvasPosition(event);

            switch(state.activeTool) {
                case 'line':
                    // Update line end point
                    state.tempObject.geometry.attributes.position.setXYZ(1, pos.x, pos.y, pos.z);
                    state.tempObject.geometry.attributes.position.needsUpdate = true;
                    break;
                case 'rectangle':
                    // Update rectangle size
                    const width = Math.abs(pos.x - state.startPoint.x);
                    const height = Math.abs(pos.y - state.startPoint.y);
                    state.tempObject.scale.set(width * 10, height * 10, 1);
                    break;
                case 'circle':
                    // Update circle radius
                    const radius = Math.sqrt(
                        Math.pow(pos.x - state.startPoint.x, 2) + 
                        Math.pow(pos.y - state.startPoint.y, 2)
                    );
                    state.tempObject.scale.set(radius * 10, radius * 10, 1);
                    break;
            }
        }

        function endDrawing() {
            state.drawing = false;
            state.tempObject = null;
            state.startPoint = null;
        }

        function getCanvasPosition(event) {
            state.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            state.pointer.y = - (event.clientY / (window.innerHeight - 128)) * 2 + 1;
            state.raycaster.setFromCamera(state.pointer, state.camera);
            
            // Create a plane at z=0 for drawing
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const intersection = new THREE.Vector3();
            state.raycaster.ray.intersectPlane(plane, intersection);
            
            return intersection;
        }

        // Context Menu
        function showContextMenu(x, y, obj) {
            state.selectedObject = obj;
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
        }

        function hideContextMenu() {
            contextMenu.style.display = 'none';
        }

        function handleContextAction(action) {
            if (!state.selectedObject) return;

            switch(action) {
                case 'group':
                    // Group selected objects
                    alert('Group functionality would be implemented here');
                    break;
                case 'delete':
                    state.scene.remove(state.selectedObject);
                    state.objects = state.objects.filter(obj => obj !== state.selectedObject);
                    break;
                // Add other actions
            }
            hideContextMenu();
        }

        // Material Functions
        function selectColor(color) {
            if (state.selectedObject && state.selectedObject.material) {
                state.selectedObject.material.color.setHex(parseInt(color.substring(1), 16));
            }
        }

        // Unit System
        function selectUnit(unit) {
            state.unit = unit;
            unitBtns.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.unit === unit) {
                    btn.classList.add('active');
                }
            });
        }

        // File Operations
        function saveProject() {
            const project = {
                date: new Date().toISOString(),
                objects: state.objects.length,
                unit: state.unit
            };
            localStorage.setItem('kaarigarProject', JSON.stringify(project));
            alert('Project saved!');
        }

        function loadProject() {
            const project = localStorage.getItem('kaarigarProject');
            if (project) {
                alert('Loaded project with ' + JSON.parse(project).objects + ' objects');
            } else {
                alert('No saved project found');
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // Menu button
            menuBtn.addEventListener('click', () => {
                sidePanel.classList.toggle('open');
            });

            // Tool buttons
            toolBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    selectTool(btn.dataset.tool);
                });
            });

            // Color options
            colorOptions.forEach(option => {
                option.addEventListener('click', () => {
                    colorOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    selectColor(option.dataset.color);
                });
            });

            // Unit buttons
            unitBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    selectUnit(btn.dataset.unit);
                });
            });

            // Context menu items
            document.querySelectorAll('.context-item').forEach(item => {
                item.addEventListener('click', () => {
                    handleContextAction(item.dataset.action);
                });
            });

            // Canvas interactions
            state.renderer.domElement.addEventListener('click', handleCanvasClick);
            state.renderer.domElement.addEventListener('mousemove', handleDrawing);
            state.renderer.domElement.addEventListener('mouseup', endDrawing);
            document.addEventListener('click', hideContextMenu);

            // File operations
            document.querySelector('[data-tool="save"]').addEventListener('click', saveProject);
            document.querySelector('[data-tool="load"]').addEventListener('click', loadProject);
        }

        // Initialize App
        function init() {
            initScene();
            setupEventListeners();
            selectTool('line'); // Start with line tool selected
        }

        // Start the app
        init();
    </script>
</body>
</html>
