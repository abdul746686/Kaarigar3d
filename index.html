<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kaarigar3D - Furniture Design</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            width: 100vw;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        /* Header Styles */
        .app-header {
            background-color: #ffffff;
            color: #333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .logo {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4a6fa5;
        }

        .menu-btn {
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            width: 100%;
            position: relative;
            overflow: hidden;
            background-color: #e9e9e9;
        }

        /* Toolbar Styles */
        .toolbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #ffffff;
            padding: 10px;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
            z-index: 100;
            overflow-x: auto;
            white-space: nowrap;
        }

        .tool-section {
            display: flex;
            gap: 10px;
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 8px;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .tool-btn:hover {
            background-color: #e0e0e0;
        }

        .tool-btn.active {
            background-color: #4a6fa5;
            color: white;
        }

        .tool-btn .icon {
            font-size: 1.5rem;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 1000;
        }

        .tool-btn:hover .tooltip,
        .tool-btn:active .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* More Tools Panel */
        .more-tools-panel {
            position: fixed;
            bottom: 70px;
            left: 0;
            right: 0;
            background-color: #ffffff;
            padding: 15px;
            border-radius: 15px 15px 0 0;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.2);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 90;
            max-height: 60vh;
            overflow-y: auto;
        }

        .more-tools-panel.show {
            transform: translateY(0);
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            z-index: 110;
            transition: transform 0.3s ease;
        }

        .context-menu.show {
            transform: translateX(-50%) translateY(0);
        }

        .context-menu-header {
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .context-menu-items {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            padding: 10px;
        }

        .context-menu-items button {
            padding: 10px;
            border: none;
            background-color: #f5f5f5;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .context-menu-items button:hover {
            background-color: #e0e0e0;
        }

        /* Material Panel */
        .material-panel {
            position: fixed;
            bottom: 70px;
            left: 0;
            right: 0;
            background-color: #ffffff;
            padding: 15px;
            border-radius: 15px 15px 0 0;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.2);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 90;
            max-height: 60vh;
            overflow-y: auto;
        }

        .material-panel.show {
            transform: translateY(0);
        }

        .material-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .material-item {
            aspect-ratio: 1;
            border-radius: 5px;
            border: 1px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .material-item:hover {
            transform: scale(1.1);
        }

        .texture-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .texture-btn {
            padding: 8px 12px;
            background-color: #f5f5f5;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .texture-btn:hover {
            background-color: #e0e0e0;
        }

        /* Main Menu */
        .main-menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 200;
            display: flex;
            justify-content: flex-end;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .main-menu.show {
            opacity: 1;
            pointer-events: all;
        }

        .menu-content {
            width: 80%;
            max-width: 300px;
            background-color: white;
            height: 100%;
            overflow-y: auto;
        }

        .menu-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .menu-items {
            display: flex;
            flex-direction: column;
            padding: 10px;
        }

        .menu-items button {
            padding: 15px;
            text-align: left;
            border: none;
            background: none;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 5px;
        }

        .menu-items button:hover {
            background-color: #f5f5f5;
        }

        /* Modal Dialogs */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal.show {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background-color: #ffffff;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            overflow: hidden;
        }

        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .modal-body {
            padding: 15px;
        }

        .modal-footer {
            padding: 15px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid #eee;
        }

        /* Close Button */
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        /* Input Styles */
        input[type="text"], select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        /* Project List */
        .project-list {
            max-height: 50vh;
            overflow-y: auto;
        }

        .project-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .project-item:hover {
            background-color: #f5f5f5;
        }

        /* Responsive Adjustments */
        @media (max-width: 480px) {
            .tool-btn {
                width: 45px;
                height: 45px;
                font-size: 1rem;
            }
            
            .tool-btn .icon {
                font-size: 1.2rem;
            }
            
            .material-grid {
                grid-template-columns: repeat(5, 1fr);
            }
        }

        /* Animation for selected objects */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .selected-object {
            animation: pulse 1.5s infinite;
        }

        /* Grid helper */
        .grid-helper {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Measurement labels */
        .measurement-label {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <div class="logo">Kaarigar3D</div>
            <div class="menu-btn" id="mainMenuBtn">‚ò∞</div>
        </header>

        <div class="canvas-container" id="canvasContainer">
            <!-- 3D canvas will be inserted here by JavaScript -->
        </div>

        <div class="toolbar" id="mainToolbar">
            <div class="tool-section">
                <button class="tool-btn active" data-tool="select" title="Select Tool">
                    <span class="icon">‚úèÔ∏è</span>
                    <span class="tooltip">Select</span>
                </button>
                <button class="tool-btn" data-tool="move" title="Move">
                    <span class="icon">‚ÜîÔ∏è</span>
                    <span class="tooltip">Move</span>
                </button>
                <button class="tool-btn" data-tool="rotate" title="Rotate">
                    <span class="icon">üîÑ</span>
                    <span class="tooltip">Rotate</span>
                </button>
                <button class="tool-btn" data-tool="scale" title="Scale">
                    <span class="icon">üìè</span>
                    <span class="tooltip">Scale</span>
                </button>
                <button class="tool-btn" data-tool="pushpull" title="Push/Pull">
                    <span class="icon">‚ÜïÔ∏è</span>
                    <span class="tooltip">Push/Pull</span>
                </button>
            </div>

            <div class="tool-section">
                <button class="tool-btn" data-tool="line" title="Line">
                    <span class="icon">üìè</span>
                    <span class="tooltip">Line</span>
                </button>
                <button class="tool-btn" data-tool="rectangle" title="Rectangle">
                    <span class="icon">‚¨õ</span>
                    <span class="tooltip">Rectangle</span>
                </button>
                <button class="tool-btn" data-tool="circle" title="Circle">
                    <span class="icon">‚≠ï</span>
                    <span class="tooltip">Circle</span>
                </button>
                <button class="tool-btn" data-tool="arc" title="Arc">
                    <span class="icon">‚åí</span>
                    <span class="tooltip">Arc</span>
                </button>
                <button class="tool-btn" data-tool="polygon" title="Polygon">
                    <span class="icon">üî∂</span>
                    <span class="tooltip">Polygon</span>
                </button>
            </div>

            <div class="tool-section">
                <button class="tool-btn" data-tool="paint" title="Paint Bucket">
                    <span class="icon">üé®</span>
                    <span class="tooltip">Paint</span>
                </button>
                <button class="tool-btn" data-tool="eyedropper" title="Eyedropper">
                    <span class="icon">üíß</span>
                    <span class="tooltip">Eyedropper</span>
                </button>
                <button class="tool-btn" data-tool="text" title="Add Text">
                    <span class="icon">üî§</span>
                    <span class="tooltip">Text</span>
                </button>
                <button class="tool-btn" data-tool="image" title="Add Image">
                    <span class="icon">üñºÔ∏è</span>
                    <span class="tooltip">Image</span>
                </button>
                <button class="tool-btn" id="moreToolsBtn" title="More Tools">
                    <span class="icon">‚ãØ</span>
                    <span class="tooltip">More Tools</span>
                </button>
            </div>
        </div>

        <!-- More Tools Panel -->
        <div class="more-tools-panel" id="moreToolsPanel">
            <div class="tools-grid">
                <!-- View Tools -->
                <button class="tool-btn" data-tool="orbit" title="Orbit">
                    <span class="icon">üåç</span>
                    <span class="tooltip">Orbit</span>
                </button>
                <button class="tool-btn" data-tool="pan" title="Pan">
                    <span class="icon">‚úã</span>
                    <span class="tooltip">Pan</span>
                </button>
                <button class="tool-btn" data-tool="zoomin" title="Zoom In">
                    <span class="icon">‚ûï</span>
                    <span class="tooltip">Zoom In</span>
                </button>
                <button class="tool-btn" data-tool="zoomout" title="Zoom Out">
                    <span class="icon">‚ûñ</span>
                    <span class="tooltip">Zoom Out</span>
                </button>
                <button class="tool-btn" data-tool="zoomextents" title="Zoom Extents">
                    <span class="icon">üîç</span>
                    <span class="tooltip">Zoom Extents</span>
                </button>

                <!-- Measure Tools -->
                <button class="tool-btn" data-tool="ruler" title="Ruler">
                    <span class="icon">üìê</span>
                    <span class="tooltip">Ruler</span>
                </button>
                <button class="tool-btn" data-tool="dimension" title="Dimension">
                    <span class="icon">üìè</span>
                    <span class="tooltip">Dimension</span>
                </button>
                <button class="tool-btn" data-tool="protractor" title="Protractor">
                    <span class="icon">üìê</span>
                    <span class="tooltip">Protractor</span>
                </button>
                <button class="tool-btn" data-tool="area" title="Area">
                    <span class="icon">üî≤</span>
                    <span class="tooltip">Area</span>
                </button>
                <button class="tool-btn" data-tool="volume" title="Volume">
                    <span class="icon">üßä</span>
                    <span class="tooltip">Volume</span>
                </button>

                <!-- Edit Tools -->
                <button class="tool-btn" data-tool="group" title="Group">
                    <span class="icon">üë•</span>
                    <span class="tooltip">Group</span>
                </button>
                <button class="tool-btn" data-tool="ungroup" title="Ungroup">
                    <span class="icon">üë§</span>
                    <span class="tooltip">Ungroup</span>
                </button>
                <button class="tool-btn" data-tool="component" title="Make Component">
                    <span class="icon">üß©</span>
                    <span class="tooltip">Component</span>
                </button>
                <button class="tool-btn" data-tool="explode" title="Explode">
                    <span class="icon">üí•</span>
                    <span class="tooltip">Explode</span>
                </button>
                <button class="tool-btn" data-tool="duplicate" title="Duplicate">
                    <span class="icon">‚úÇÔ∏è</span>
                    <span class="tooltip">Duplicate</span>
                </button>
                <button class="tool-btn" data-tool="delete" title="Delete">
                    <span class="icon">üóëÔ∏è</span>
                    <span class="tooltip">Delete</span>
                </button>
                <button class="tool-btn" data-tool="hide" title="Hide">
                    <span class="icon">üëÅÔ∏è</span>
                    <span class="tooltip">Hide</span>
                </button>
                <button class="tool-btn" data-tool="unhide" title="Unhide">
                    <span class="icon">üëÅÔ∏è‚Äçüó®Ô∏è</span>
                    <span class="tooltip">Unhide</span>
                </button>

                <!-- View Presets -->
                <button class="tool-btn" data-tool="topview" title="Top View">
                    <span class="icon">‚¨ÜÔ∏è</span>
                    <span class="tooltip">Top View</span>
                </button>
                <button class="tool-btn" data-tool="frontview" title="Front View">
                    <span class="icon">‚¨áÔ∏è</span>
                    <span class="tooltip">Front View</span>
                </button>
                <button class="tool-btn" data-tool="sideview" title="Side View">
                    <span class="icon">‚¨ÖÔ∏è</span>
                    <span class="tooltip">Side View</span>
                </button>
                <button class="tool-btn" data-tool="grid" title="Toggle Grid">
                    <span class="icon">#Ô∏è‚É£</span>
                    <span class="tooltip">Grid</span>
                </button>
                <button class="tool-btn" data-tool="snap" title="Snap to Grid">
                    <span class="icon">üß≤</span>
                    <span class="tooltip">Snap</span>
                </button>
            </div>
        </div>

        <!-- Context Menu -->
        <div class="context-menu" id="contextMenu">
            <div class="context-menu-header">
                <span>Object Options</span>
                <button class="close-btn" id="closeContextMenu">√ó</button>
            </div>
            <div class="context-menu-items">
                <button data-action="group">Group</button>
                <button data-action="ungroup">Ungroup</button>
                <button data-action="hide">Hide</button>
                <button data-action="unhide">Unhide</button>
                <button data-action="component">Make Component</button>
                <button data-action="explode">Explode</button>
                <button data-action="duplicate">Duplicate</button>
                <button data-action="delete">Delete</button>
            </div>
        </div>

        <!-- Material Panel -->
        <div class="material-panel" id="materialPanel">
            <div class="material-panel-header">
                <span>Materials</span>
                <button class="close-btn" id="closeMaterialPanel">√ó</button>
            </div>
            <div class="material-grid">
                <div class="material-item" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <div class="material-item" data-color="#f5f5f5" style="background-color: #f5f5f5;"></div>
                <div class="material-item" data-color="#e0e0e0" style="background-color: #e0e0e0;"></div>
                <div class="material-item" data-color="#bdbdbd" style="background-color: #bdbdbd;"></div>
                <div class="material-item" data-color="#9e9e9e" style="background-color: #9e9e9e;"></div>
                <div class="material-item" data-color="#757575" style="background-color: #757575;"></div>
                <div class="material-item" data-color="#616161" style="background-color: #616161;"></div>
                <div class="material-item" data-color="#424242" style="background-color: #424242;"></div>
                <div class="material-item" data-color="#212121" style="background-color: #212121;"></div>
                <div class="material-item" data-color="#f44336" style="background-color: #f44336;"></div>
                <div class="material-item" data-color="#e91e63" style="background-color: #e91e63;"></div>
                <div class="material-item" data-color="#9c27b0" style="background-color: #9c27b0;"></div>
                <div class="material-item" data-color="#673ab7" style="background-color: #673ab7;"></div>
                <div class="material-item" data-color="#3f51b5" style="background-color: #3f51b5;"></div>
                <div class="material-item" data-color="#2196f3" style="background-color: #2196f3;"></div>
                <div class="material-item" data-color="#03a9f4" style="background-color: #03a9f4;"></div>
                <div class="material-item" data-color="#00bcd4" style="background-color: #00bcd4;"></div>
                <div class="material-item" data-color="#009688" style="background-color: #009688;"></div>
                <div class="material-item" data-color="#4caf50" style="background-color: #4caf50;"></div>
                <div class="material-item" data-color="#8bc34a" style="background-color: #8bc34a;"></div>
                <div class="material-item" data-color="#cddc39" style="background-color: #cddc39;"></div>
                <div class="material-item" data-color="#ffeb3b" style="background-color: #ffeb3b;"></div>
                <div class="material-item" data-color="#ffc107" style="background-color: #ffc107;"></div>
                <div class="material-item" data-color="#ff9800" style="background-color: #ff9800;"></div>
                <div class="material-item" data-color="#ff5722" style="background-color: #ff5722;"></div>
                <div class="material-item" data-color="#795548" style="background-color: #795548;"></div>
                <div class="material-item" data-color="#607d8b" style="background-color: #607d8b;"></div>
                <div class="material-item" data-color="#9e9e9e" style="background-color: #9e9e9e;"></div>
                <div class="material-item" data-color="#000000" style="background-color: #000000;"></div>
            </div>
            <div class="texture-options">
                <button class="texture-btn" data-texture="wood">Wood</button>
                <button class="texture-btn" data-texture="metal">Metal</button>
                <button class="texture-btn" data-texture="fabric">Fabric</button>
                <button class="texture-btn" data-texture="glass">Glass</button>
                <button class="texture-btn" data-texture="stone">Stone</button>
            </div>
            <div style="margin-top: 15px;">
                <label for="transparencySlider">Transparency:</label>
                <input type="range" id="transparencySlider" min="0" max="100" value="0">
            </div>
        </div>

        <!-- Main Menu -->
        <div class="main-menu" id="mainMenu">
            <div class="menu-content">
                <div class="menu-header">
                    <span>Menu</span>
                    <button class="close-btn" id="closeMainMenu">√ó</button>
                </div>
                <div class="menu-items">
                    <button id="newProjectBtn">New Project</button>
                    <button id="openProjectBtn">Open Project</button>
                    <button id="saveProjectBtn">Save Project</button>
                    <button id="exportImageBtn">Export as Image</button>
                    <button id="export3DBtn">Export 3D Model</button>
                    <div style="padding: 15px;">
                        <label for="unitSelect">Measurement Units:</label>
                        <select id="unitSelect">
                            <option value="mm">Millimeters (mm)</option>
                            <option value="cm">Centimeters (cm)</option>
                            <option value="in">Inches (in)</option>
                            <option value="ft" selected>Feet (ft)</option>
                        </select>
                    </div>
                    <button id="helpBtn">Help & Tutorials</button>
                    <button id="settingsBtn">Settings</button>
                </div>
            </div>
        </div>

        <!-- Save Modal -->
        <div class="modal" id="saveModal">
            <div class="modal-content">
                <div class="modal-header">
                    <span>Save Project</span>
                    <button class="close-btn" id="closeSaveModal">√ó</button>
                </div>
                <div class="modal-body">
                    <input type="text" id="projectName" placeholder="Project Name">
                </div>
                <div class="modal-footer">
                    <button id="confirmSave">Save</button>
                    <button id="cancelSave">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Load Modal -->
        <div class="modal" id="loadModal">
            <div class="modal-content">
                <div class="modal-header">
                    <span>Load Project</span>
                    <button class="close-btn" id="closeLoadModal">√ó</button>
                </div>
                <div class="modal-body">
                    <div class="project-list" id="projectList">
                        <!-- Projects will be listed here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="cancelLoad">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Export Modal -->
        <div class="modal" id="exportModal">
            <div class="modal-content">
                <div class="modal-header">
                    <span>Export Options</span>
                    <button class="close-btn" id="closeExportModal">√ó</button>
                </div>
                <div class="modal-body">
                    <label for="exportFormat">Format:</label>
                    <select id="exportFormat">
                        <option value="png">PNG Image</option>
                        <option value="jpg">JPG Image</option>
                        <option value="obj">OBJ 3D Model</option>
                        <option value="stl">STL 3D Model</option>
                    </select>
                </div>
                <div class="modal-footer">
                    <button id="confirmExport">Export</button>
                    <button id="cancelExport">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js and other libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>

    <script>
        // Kaarigar3D - Mobile 3D Furniture Design App
        // Main Application Script

        // Global Variables
        let scene, camera, renderer, controls;
        let objects = [];
        let selectedObjects = [];
        let currentTool = 'select';
        let isDrawing = false;
        let drawingObject = null;
        let startPoint = null;
        let gridVisible = true;
        let snapToGrid = true;
        let gridSize = 1;
        let lastClickTime = 0;
        let lastSelectedObject = null;
        let currentColor = new THREE.Color(0x4a6fa5);
        let currentTexture = null;
        let currentTransparency = 0;
        let measurementLabels = [];
        let measurementMode = null;
        let measurementStartPoint = null;
        let measurementEndPoint = null;
        let unitSystem = 'ft'; // Default to feet

        // Initialize the application
        function init() {
            // Create Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe9e9e9);
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvasContainer').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x888888);
            scene.add(gridHelper);
            
            // Set up event listeners
            setupEventListeners();
            
            // Start animation loop
            animate();
            
            // Load any saved projects
            loadProjectList();
        }

        // Set up all event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Canvas click events
            renderer.domElement.addEventListener('click', onCanvasClick, { passive: false });
            renderer.domElement.addEventListener('dblclick', onCanvasDoubleClick, { passive: false });
            renderer.domElement.addEventListener('mousedown', onCanvasMouseDown, { passive: false });
            renderer.domElement.addEventListener('mousemove', onCanvasMouseMove, { passive: false });
            renderer.domElement.addEventListener('mouseup', onCanvasMouseUp, { passive: false });
            
            // Touch events for mobile
            renderer.domElement.addEventListener('touchstart', onCanvasTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onCanvasTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onCanvasTouchEnd, { passive: false });
            
            // Tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', onToolButtonClick);
            });
            
            // More tools button
            document.getElementById('moreToolsBtn').addEventListener('click', toggleMoreTools);
            
            // Context menu buttons
            document.querySelectorAll('.context-menu-items button').forEach(btn => {
                btn.addEventListener('click', onContextMenuAction);
            });
            
            // Close context menu
            document.getElementById('closeContextMenu').addEventListener('click', hideContextMenu);
            
            // Material panel
            document.querySelectorAll('.material-item').forEach(item => {
                item.addEventListener('click', onMaterialSelect);
            });
            
            document.querySelectorAll('.texture-btn').forEach(btn => {
                btn.addEventListener('click', onTextureSelect);
            });
            
            document.getElementById('closeMaterialPanel').addEventListener('click', hideMaterialPanel);
            
            // Transparency slider
            document.getElementById('transparencySlider').addEventListener('input', onTransparencyChange);
            
            // Main menu
            document.getElementById('mainMenuBtn').addEventListener('click', showMainMenu);
            document.getElementById('closeMainMenu').addEventListener('click', hideMainMenu);
            
            // Menu actions
            document.getElementById('newProjectBtn').addEventListener('click', newProject);
            document.getElementById('openProjectBtn').addEventListener('click', showLoadModal);
            document.getElementById('saveProjectBtn').addEventListener('click', showSaveModal);
            document.getElementById('exportImageBtn').addEventListener('click', () => showExportModal('image'));
            document.getElementById('export3DBtn').addEventListener('click', () => showExportModal('3d'));
            
            // Modal buttons
            document.getElementById('confirmSave').addEventListener('click', saveProject);
            document.getElementById('cancelSave').addEventListener('click', hideSaveModal);
            document.getElementById('closeSaveModal').addEventListener('click', hideSaveModal);
            document.getElementById('closeLoadModal').addEventListener('click', hideLoadModal);
            document.getElementById('cancelLoad').addEventListener('click', hideLoadModal);
            document.getElementById('confirmExport').addEventListener('click', exportProject);
            document.getElementById('cancelExport').addEventListener('click', hideExportModal);
            document.getElementById('closeExportModal').addEventListener('click', hideExportModal);
            
            // Unit system change
            document.getElementById('unitSelect').addEventListener('change', (e) => {
                unitSystem = e.target.value;
                updateMeasurementLabels();
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Canvas click handler
        function onCanvasClick(event) {
            event.preventDefault();
            
            const now = Date.now();
            const isDoubleClick = (now - lastClickTime) < 300;
            lastClickTime = now;
            
            if (isDoubleClick) return; // Let double click handler take care of it
            
            const mouse = getNormalizedMouseCoordinates(event);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                // Handle different tools
                switch (currentTool) {
                    case 'select':
                        handleSelectTool(intersect.object, event.shiftKey);
                        break;
                        
                    case 'paint':
                        if (intersect.object.material) {
                            applyMaterialToObject(intersect.object);
                        }
                        break;
                        
                    case 'eyedropper':
                        if (intersect.object.material) {
                            pickMaterialFromObject(intersect.object);
                        }
                        break;
                        
                    case 'ruler':
                    case 'dimension':
                    case 'protractor':
                        handleMeasurementTool(intersect.point);
                        break;
                        
                    case 'pushpull':
                        if (intersect.object.geometry && intersect.object.geometry.parameters && 
                            intersect.object.geometry.parameters.height === undefined) {
                            // This is a 2D shape that can be extruded
                            extrudeShape(intersect.object, 1); // Default extrusion of 1 unit
                        }
                        break;
                        
                    default:
                        // For other tools, start drawing/transforming
                        startPoint = intersect.point;
                        isDrawing = true;
                        createDrawingObject(currentTool, startPoint);
                        break;
                }
            } else {
                // Clicked on empty space - deselect all
                if (currentTool === 'select') {
                    clearSelection();
                }
                
                // For measurement tools, set first point
                if (currentTool === 'ruler' || currentTool === 'dimension' || currentTool === 'protractor') {
                    measurementMode = currentTool;
                    measurementStartPoint = mouse;
                }
            }
        }

        // Canvas double click handler
        function onCanvasDoubleClick(event) {
            event.preventDefault();
            
            const mouse = getNormalizedMouseCoordinates(event);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                if (currentTool === 'select') {
                    // Select the entire object (not just face)
                    selectFullObject(intersect.object);
                    
                    // Show context menu
                    showContextMenu(event.clientX, event.clientY);
                }
            }
        }

        // Canvas mouse down handler
        function onCanvasMouseDown(event) {
            if (currentTool !== 'select' && currentTool !== 'paint' && currentTool !== 'eyedropper' &&
                currentTool !== 'ruler' && currentTool !== 'dimension' && currentTool !== 'protractor') {
                const mouse = getNormalizedMouseCoordinates(event);
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObjects(scene.children, true);
                
                if (intersects.length > 0) {
                    startPoint = intersects[0].point;
                    isDrawing = true;
                    
                    // Create a new object based on the current tool
                    createDrawingObject(currentTool, startPoint);
                }
            }
        }

        // Canvas mouse move handler
        function onCanvasMouseMove(event) {
            if (isDrawing && drawingObject && startPoint) {
                const mouse = getNormalizedMouseCoordinates(event);
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObjects(scene.children, true);
                
                if (intersects.length > 0) {
                    const endPoint = intersects[0].point;
                    
                    // Update the drawing object based on the current tool
                    updateDrawingObject(drawingObject, currentTool, startPoint, endPoint);
                }
            }
            
            // For measurement tools, update the end point
            if (measurementMode && measurementStartPoint) {
                measurementEndPoint = getNormalizedMouseCoordinates(event);
                updateMeasurementVisual();
            }
        }

        // Canvas mouse up handler
        function onCanvasMouseUp(event) {
            if (isDrawing && drawingObject) {
                // Finalize the drawing object
                finalizeDrawingObject(drawingObject);
                drawingObject = null;
            }
            
            isDrawing = false;
            startPoint = null;
            
            // For measurement tools, finalize the measurement
            if (measurementMode && measurementStartPoint && measurementEndPoint) {
                finalizeMeasurement();
            }
        }

        // Touch event handlers (for mobile)
        function onCanvasTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                onCanvasMouseDown(mouseEvent);
            }
        }

        function onCanvasTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                onCanvasMouseMove(mouseEvent);
            }
        }

        function onCanvasTouchEnd(event) {
            event.preventDefault();
            if (event.touches.length === 0) {
                const mouseEvent = new MouseEvent('mouseup');
                onCanvasMouseUp(mouseEvent);
            }
        }

        // Tool button click handler
        function onToolButtonClick(event) {
            event.stopPropagation();
            
            const tool = event.currentTarget.dataset.tool;
            currentTool = tool;
            
            // Update active tool UI
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
            
            // Handle special tools
            if (tool === 'paint') {
                showMaterialPanel();
            } else {
                hideMaterialPanel();
            }
            
            // Handle view tools
            if (tool === 'orbit') {
                controls.enableRotate = true;
                controls.enablePan = false;
            } else if (tool === 'pan') {
                controls.enableRotate = false;
                controls.enablePan = true;
            } else if (tool === 'zoomin') {
                camera.fov = Math.max(10, camera.fov - 5);
                camera.updateProjectionMatrix();
            } else if (tool === 'zoomout') {
                camera.fov = Math.min(100, camera.fov + 5);
                camera.updateProjectionMatrix();
            } else if (tool === 'zoomextents') {
                zoomToExtents();
            } else if (tool === 'topview') {
                setTopView();
            } else if (tool === 'frontview') {
                setFrontView();
            } else if (tool === 'sideview') {
                setSideView();
            } else if (tool === 'grid') {
                toggleGridVisibility();
            } else if (tool === 'snap') {
                snapToGrid = !snapToGrid;
                event.currentTarget.classList.toggle('active', snapToGrid);
            }
            
            console.log(`Tool activated: ${currentTool}`);
        }

        // Create a new drawing object based on the current tool
        function createDrawingObject(tool, startPoint) {
            let geometry, material, mesh;
            
            // Snap to grid if enabled
            if (snapToGrid) {
                startPoint.x = Math.round(startPoint.x / gridSize) * gridSize;
                startPoint.y = Math.round(startPoint.y / gridSize) * gridSize;
                startPoint.z = Math.round(startPoint.z / gridSize) * gridSize;
            }
            
            // Create material based on current settings
            material = new THREE.MeshBasicMaterial({ 
                color: currentColor,
                side: THREE.DoubleSide,
                transparent: currentTransparency > 0,
                opacity: 1 - (currentTransparency / 100)
            });
            
            // Apply texture if selected
            if (currentTexture) {
                // In a real app, we'd load actual textures
                material.map = new THREE.TextureLoader().load(`textures/${currentTexture}.jpg`);
                material.needsUpdate = true;
            }
            
            switch (tool) {
                case 'line':
                    material = new THREE.LineBasicMaterial({ color: currentColor });
                    geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(6);
                    positions[0] = startPoint.x;
                    positions[1] = startPoint.y;
                    positions[2] = startPoint.z;
                    positions[3] = startPoint.x + 0.01;
                    positions[4] = startPoint.y + 0.01;
                    positions[5] = startPoint.z + 0.01;
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    drawingObject = new THREE.Line(geometry, material);
                    break;
                    
                case 'rectangle':
                    geometry = new THREE.PlaneGeometry(0.1, 0.1);
                    drawingObject = new THREE.Mesh(geometry, material);
                    drawingObject.rotation.x = -Math.PI / 2;
                    break;
                    
                case 'circle':
                    geometry = new THREE.CircleGeometry(0.1, 32);
                    drawingObject = new THREE.Mesh(geometry, material);
                    drawingObject.rotation.x = -Math.PI / 2;
                    break;
                    
                case 'arc':
                    // Create a simple arc (quarter circle)
                    const arcShape = new THREE.Shape()
                        .moveTo(0, 0)
                        .absarc(0, 0, 0.1, 0, Math.PI / 2, false);
                    geometry = new THREE.ShapeGeometry(arcShape);
                    drawingObject = new THREE.Mesh(geometry, material);
                    drawingObject.rotation.x = -Math.PI / 2;
                    break;
                    
                case 'polygon':
                    // Create a hexagon by default
                    const sides = 6;
                    const radius = 0.1;
                    const shape = new THREE.Shape();
                    shape.moveTo(radius * Math.cos(0), radius * Math.sin(0));
                    
                    for (let i = 1; i <= sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        shape.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
                    }
                    
                    geometry = new THREE.ShapeGeometry(shape);
                    drawingObject = new THREE.Mesh(geometry, material);
                    drawingObject.rotation.x = -Math.PI / 2;
                    break;
                    
                case 'text':
                    // Simple 2D text implementation
                    geometry = new THREE.PlaneGeometry(0.5, 0.2);
                    const textMaterial = new THREE.MeshBasicMaterial({ 
                        color: currentColor,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 1 - (currentTransparency / 100)
                    });
                    drawingObject = new THREE.Mesh(geometry, textMaterial);
                    drawingObject.userData.isText = true;
                    drawingObject.userData.text = "Sample Text";
                    break;
                    
                case 'image':
                    // Simple image plane
                    geometry = new THREE.PlaneGeometry(0.5, 0.5);
                    const imageMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 1 - (currentTransparency / 100)
                    });
                    // In a real app, we'd load an actual image texture
                    drawingObject = new THREE.Mesh(geometry, imageMaterial);
                    drawingObject.userData.isImage = true;
                    break;
                    
                default:
                    // Default cube for other tools
                    geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    drawingObject = new THREE.Mesh(geometry, material);
            }
            
            drawingObject.position.copy(startPoint);
            scene.add(drawingObject);
            return drawingObject;
        }

        // Update the drawing object based on mouse movement
        function updateDrawingObject(obj, tool, startPoint, endPoint) {
            if (!obj) return;
            
            // Snap to grid if enabled
            if (snapToGrid) {
                endPoint.x = Math.round(endPoint.x / gridSize) * gridSize;
                endPoint.y = Math.round(endPoint.y / gridSize) * gridSize;
                endPoint.z = Math.round(endPoint.z / gridSize) * gridSize;
            }
            
            switch (tool) {
                case 'line':
                    const lineGeometry = obj.geometry;
                    const positions = new Float32Array(6);
                    positions[0] = startPoint.x;
                    positions[1] = startPoint.y;
                    positions[2] = startPoint.z;
                    positions[3] = endPoint.x;
                    positions[4] = endPoint.y;
                    positions[5] = endPoint.z;
                    lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    break;
                    
                case 'rectangle':
                    const width = Math.abs(endPoint.x - startPoint.x);
                    const depth = Math.abs(endPoint.z - startPoint.z);
                    obj.geometry.dispose();
                    obj.geometry = new THREE.PlaneGeometry(width, depth);
                    
                    // Position at center between start and end points
                    obj.position.x = (startPoint.x + endPoint.x) / 2;
                    obj.position.z = (startPoint.z + endPoint.z) / 2;
                    break;
                    
                case 'circle':
                    const radius = Math.sqrt(
                        Math.pow(endPoint.x - startPoint.x, 2) + 
                        Math.pow(endPoint.z - startPoint.z, 2)
                    );
                    obj.geometry.dispose();
                    obj.geometry = new THREE.CircleGeometry(radius, 32);
                    break;
                    
                case 'arc':
                    // Update arc radius
                    const arcRadius = Math.sqrt(
                        Math.pow(endPoint.x - startPoint.x, 2) + 
                        Math.pow(endPoint.z - startPoint.z, 2)
                    );
                    const arcShape = new THREE.Shape()
                        .moveTo(0, 0)
                        .absarc(0, 0, arcRadius, 0, Math.PI / 2, false);
                    obj.geometry.dispose();
                    obj.geometry = new THREE.ShapeGeometry(arcShape);
                    break;
                    
                case 'polygon':
                    // Update polygon size
                    const polyRadius = Math.sqrt(
                        Math.pow(endPoint.x - startPoint.x, 2) + 
                        Math.pow(endPoint.z - startPoint.z, 2)
                    );
                    const sides = obj.userData.sides || 6;
                    const shape = new THREE.Shape();
                    shape.moveTo(polyRadius * Math.cos(0), polyRadius * Math.sin(0));
                    
                    for (let i = 1; i <= sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        shape.lineTo(polyRadius * Math.cos(angle), polyRadius * Math.sin(angle));
                    }
                    
                    obj.geometry.dispose();
                    obj.geometry = new THREE.ShapeGeometry(shape);
                    break;
                    
                case 'text':
                    // Update text size
                    const textWidth = Math.abs(endPoint.x - startPoint.x);
                    const textHeight = Math.abs(endPoint.y - startPoint.y);
                    obj.geometry.dispose();
                    obj.geometry = new THREE.PlaneGeometry(textWidth, textHeight);
                    
                    // Position at center
                    obj.position.x = (startPoint.x + endPoint.x) / 2;
                    obj.position.y = (startPoint.y + endPoint.y) / 2;
                    obj.position.z = startPoint.z;
                    break;
                    
                case 'image':
                    // Update image size
                    const imgWidth = Math.abs(endPoint.x - startPoint.x);
                    const imgHeight = Math.abs(endPoint.y - startPoint.y);
                    obj.geometry.dispose();
                    obj.geometry = new THREE.PlaneGeometry(imgWidth, imgHeight);
                    
                    // Position at center
                    obj.position.x = (startPoint.x + endPoint.x) / 2;
                    obj.position.y = (startPoint.y + endPoint.y) / 2;
                    obj.position.z = startPoint.z;
                    break;
                    
                default:
                    // For other tools (like box), scale between start and end points
                    const scaleX = Math.abs(endPoint.x - startPoint.x);
                    const scaleY = Math.abs(endPoint.y - startPoint.y);
                    const scaleZ = Math.abs(endPoint.z - startPoint.z);
                    
                    obj.scale.set(scaleX, scaleY, scaleZ);
                    
                    // Position at center between start and end points
                    obj.position.x = (startPoint.x + endPoint.x) / 2;
                    obj.position.y = (startPoint.y + endPoint.y) / 2;
                    obj.position.z = (startPoint.z + endPoint.z) / 2;
            }
        }

        // Finalize the drawing object when mouse is released
        function finalizeDrawingObject(obj) {
            if (!obj) return;
            
            // Change material to be opaque if not transparent
            if (obj.material && currentTransparency === 0) {
                obj.material.transparent = false;
                obj.material.opacity = 1;
            }
            
            // Add to objects array
            objects.push(obj);
            
            // Select the new object
            clearSelection();
            selectObject(obj);
        }

        // Handle select tool
        function handleSelectTool(object, multiSelect) {
            if (currentTool !== 'select') return;
            
            if (!multiSelect) {
                clearSelection();
            }
            
            // Find the top-level parent if this is a child object
            let selectedObj = object;
            while (selectedObj.parent && selectedObj.parent !== scene) {
                selectedObj = selectedObj.parent;
            }
            
            selectObject(selectedObj);
        }

        // Select an object
        function selectObject(object) {
            if (!object) return;
            
            // Highlight the object
            if (object.material) {
                object.userData.originalColor = object.material.color.clone();
                object.material.color.set(0x00ff00); // Green for selection
            }
            
            selectedObjects.push(object);
            lastSelectedObject = object;
        }

        // Select the full object (not just face)
        function selectFullObject(object) {
            // Traverse up to find the parent object if this is a child (like a face)
            let parent = object;
            while (parent.parent && parent.parent !== scene) {
                parent = parent.parent;
            }
            
            clearSelection();
            selectObject(parent);
        }

        // Clear current selection
        function clearSelection() {
            selectedObjects.forEach(obj => {
                if (obj.material && obj.userData.originalColor) {
                    obj.material.color.copy(obj.userData.originalColor);
                }
            });
            
            selectedObjects = [];
        }

        // Toggle more tools panel
        function toggleMoreTools() {
            const panel = document.getElementById('moreToolsPanel');
            panel.classList.toggle('show');
        }

        // Show context menu
        function showContextMenu(x, y) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.classList.add('show');
        }

        // Hide context menu
        function hideContextMenu() {
            document.getElementById('contextMenu').classList.remove('show');
        }

        // Context menu action handler
        function onContextMenuAction(event) {
            const action = event.currentTarget.dataset.action;
            
            switch (action) {
                case 'group':
                    groupSelectedObjects();
                    break;
                    
                case 'ungroup':
                    ungroupSelectedObjects();
                    break;
                    
                case 'hide':
                    hideSelectedObjects();
                    break;
                    
                case 'unhide':
                    unhideAllObjects();
                    break;
                    
                case 'component':
                    convertToComponent();
                    break;
                    
                case 'explode':
                    explodeComponent();
                    break;
                    
                case 'duplicate':
                    duplicateSelectedObjects();
                    break;
                    
                case 'delete':
                    deleteSelectedObjects();
                    break;
            }
            
            hideContextMenu();
        }

        // Group selected objects
        function groupSelectedObjects() {
            if (selectedObjects.length < 2) return;
            
            const group = new THREE.Group();
            
            selectedObjects.forEach(obj => {
                scene.remove(obj);
                group.add(obj);
            });
            
            scene.add(group);
            objects.push(group);
            clearSelection();
            selectObject(group);
        }

        // Ungroup selected objects
        function ungroupSelectedObjects() {
            if (selectedObjects.length === 0) return;
            
            const newSelections = [];
            
            selectedObjects.forEach(obj => {
                if (obj instanceof THREE.Group && obj.children.length > 0) {
                    const children = [...obj.children];
                    
                    scene.remove(obj);
                    objects = objects.filter(o => o !== obj);
                    
                    children.forEach(child => {
                        scene.add(child);
                        objects.push(child);
                        newSelections.push(child);
                    });
                }
            });
            
            clearSelection();
            newSelections.forEach(obj => selectObject(obj));
        }

        // Hide selected objects
        function hideSelectedObjects() {
            selectedObjects.forEach(obj => {
                obj.visible = false;
            });
            
            clearSelection();
        }

        // Unhide all objects
        function unhideAllObjects() {
            objects.forEach(obj => {
                obj.visible = true;
            });
        }

        // Convert to component
        function convertToComponent() {
            selectedObjects.forEach(obj => {
                obj.userData.isComponent = true;
                obj.userData.componentName = `Component_${Date.now()}`;
            });
        }

        // Explode component
        function explodeComponent() {
            selectedObjects.forEach(obj => {
                if (obj.userData.isComponent) {
                    obj.userData.isComponent = false;
                }
            });
        }

        // Duplicate selected objects
        function duplicateSelectedObjects() {
            const newObjects = [];
            
            selectedObjects.forEach(obj => {
                const clone = obj.clone();
                clone.position.x += 0.5; // Offset slightly
                
                if (clone.material) {
                    clone.material = clone.material.clone();
                }
                
                scene.add(clone);
                objects.push(clone);
                newObjects.push(clone);
            });
            
            clearSelection();
            newObjects.forEach(obj => selectObject(obj));
        }

        // Delete selected objects
        function deleteSelectedObjects() {
            selectedObjects.forEach(obj => {
                scene.remove(obj);
                objects = objects.filter(o => o !== obj);
                
                // Dispose of geometry and materials to free memory
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });
            
            clearSelection();
        }

        // Show material panel
        function showMaterialPanel() {
            document.getElementById('materialPanel').classList.add('show');
        }

        // Hide material panel
        function hideMaterialPanel() {
            document.getElementById('materialPanel').classList.remove('show');
        }

        // Material selection handler
        function onMaterialSelect(event) {
            const color = event.currentTarget.dataset.color;
            currentColor = new THREE.Color(color);
            
            // Apply to selected objects
            applyMaterialToSelected();
        }

        // Texture selection handler
        function onTextureSelect(event) {
            const textureType = event.currentTarget.dataset.texture;
            currentTexture = textureType;
            
            // Apply to selected objects
            applyMaterialToSelected();
        }

        // Transparency change handler
        function onTransparencyChange(event) {
            currentTransparency = parseInt(event.target.value);
            
            // Apply to selected objects
            applyMaterialToSelected();
        }

        // Apply current material settings to selected objects
        function applyMaterialToSelected() {
            selectedObjects.forEach(obj => {
                applyMaterialToObject(obj);
            });
        }

        // Apply current material settings to a specific object
        function applyMaterialToObject(obj) {
            if (obj.material) {
                // Handle single material or array of materials
                const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                
                materials.forEach(material => {
                    material.color.copy(currentColor);
                    material.transparent = currentTransparency > 0;
                    material.opacity = 1 - (currentTransparency / 100);
                    
                    if (currentTexture) {
                        // In a real app, we'd load the actual texture
                        material.map = new THREE.TextureLoader().load(`textures/${currentTexture}.jpg`);
                        material.needsUpdate = true;
                    }
                });
            }
        }

        // Pick material from an object
        function pickMaterialFromObject(obj) {
            if (obj.material) {
                const material = Array.isArray(obj.material) ? obj.material[0] : obj.material;
                currentColor = material.color.clone();
                currentTransparency = material.transparent ? (1 - material.opacity) * 100 : 0;
                
                // Update UI
                document.getElementById('transparencySlider').value = currentTransparency;
            }
        }

        // Extrude a 2D shape into 3D
        function extrudeShape(shape, height) {
            if (!shape.geometry) return;
            
            const extrudeSettings = {
                depth: height,
                bevelEnabled: false
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape.geometry, extrudeSettings);
            const material = new THREE.MeshBasicMaterial({ 
                color: currentColor,
                transparent: currentTransparency > 0,
                opacity: 1 - (currentTransparency / 100)
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(shape.position);
            mesh.rotation.copy(shape.rotation);
            
            scene.remove(shape);
            objects = objects.filter(o => o !== shape);
            scene.add(mesh);
            objects.push(mesh);
            
            // Select the new extruded object
            clearSelection();
            selectObject(mesh);
        }

        // Handle measurement tools
        function handleMeasurementTool(point) {
            if (!measurementStartPoint) {
                measurementStartPoint = point;
            } else {
                measurementEndPoint = point;
                finalizeMeasurement();
            }
        }

        // Update measurement visualization
        function updateMeasurementVisual() {
            // Clear previous measurement visuals
            clearMeasurementVisuals();
            
            if (!measurementStartPoint || !measurementEndPoint) return;
            
            // Create a line for the measurement
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
            
            const positions = new Float32Array(6);
            positions[0] = measurementStartPoint.x;
            positions[1] = measurementStartPoint.y;
            positions[2] = measurementStartPoint.z;
            positions[3] = measurementEndPoint.x;
            positions[4] = measurementEndPoint.y;
            positions[5] = measurementEndPoint.z;
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            measurementLabels.push(line);
            
            // Calculate distance
            const distance = measurementStartPoint.distanceTo(measurementEndPoint);
            const displayDistance = convertUnits(distance);
            
            // Create label
            const label = document.createElement('div');
            label.className = 'measurement-label';
            label.textContent = `${displayDistance.toFixed(2)} ${getUnitSymbol()}`;
            label.style.position = 'absolute';
            label.style.left = '50%';
            label.style.top = '50%';
            document.body.appendChild(label);
            measurementLabels.push(label);
        }

        // Finalize measurement
        function finalizeMeasurement() {
            if (!measurementStartPoint || !measurementEndPoint) return;
            
            const distance = measurementStartPoint.distanceTo(measurementEndPoint);
            const displayDistance = convertUnits(distance);
            
            alert(`Measurement: ${displayDistance.toFixed(2)} ${getUnitSymbol()}`);
            
            // Reset measurement
            clearMeasurementVisuals();
            measurementMode = null;
            measurementStartPoint = null;
            measurementEndPoint = null;
        }

        // Clear measurement visuals
        function clearMeasurementVisuals() {
            measurementLabels.forEach(item => {
                if (item instanceof THREE.Line) {
                    scene.remove(item);
                    item.geometry.dispose();
                    item.material.dispose();
                } else if (item instanceof HTMLElement) {
                    item.remove();
                }
            });
            measurementLabels = [];
        }

        // Convert units based on current system
        function convertUnits(value) {
            switch (unitSystem) {
                case 'mm': return value * 304.8; // feet to mm
                case 'cm': return value * 30.48;  // feet to cm
                case 'in': return value * 12;     // feet to inches
                default: return value;            // feet
            }
        }

        // Get unit symbol
        function getUnitSymbol() {
            switch (unitSystem) {
                case 'mm': return 'mm';
                case 'cm': return 'cm';
                case 'in': return 'in';
                default: return 'ft';
            }
        }

        // Update all measurement labels
        function updateMeasurementLabels() {
            // In a full implementation, we'd update all existing measurement labels
        }

        // Zoom to fit all objects in view
        function zoomToExtents() {
            if (objects.length === 0) return;
            
            const bbox = new THREE.Box3();
            objects.forEach(obj => {
                bbox.expandByObject(obj);
            });
            
            const center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / Math.sin(fov / 2));
            
            // Adjust for perspective
            cameraZ *= 1.5;
            
            camera.position.copy(center);
            camera.position.z += cameraZ;
            camera.lookAt(center);
            
            controls.target.copy(center);
        }

        // Set top view
        function setTopView() {
            if (objects.length === 0) {
                camera.position.set(0, 10, 0);
                camera.lookAt(0, 0, 0);
            } else {
                const bbox = new THREE.Box3();
                objects.forEach(obj => {
                    bbox.expandByObject(obj);
                });
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.z);
                
                camera.position.set(center.x, center.y + maxDim * 1.5, center.z);
                camera.lookAt(center);
                controls.target.copy(center);
            }
        }

        // Set front view
        function setFrontView() {
            if (objects.length === 0) {
                camera.position.set(0, 0, 10);
                camera.lookAt(0, 0, 0);
            } else {
                const bbox = new THREE.Box3();
                objects.forEach(obj => {
                    bbox.expandByObject(obj);
                });
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y);
                
                camera.position.set(center.x, center.y, center.z + maxDim * 1.5);
                camera.lookAt(center);
                controls.target.copy(center);
            }
        }

        // Set side view
        function setSideView() {
            if (objects.length === 0) {
                camera.position.set(10, 0, 0);
                camera.lookAt(0, 0, 0);
            } else {
                const bbox = new THREE.Box3();
                objects.forEach(obj => {
                    bbox.expandByObject(obj);
                });
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.y, size.z);
                
                camera.position.set(center.x + maxDim * 1.5, center.y, center.z);
                camera.lookAt(center);
                controls.target.copy(center);
            }
        }

        // Toggle grid visibility
        function toggleGridVisibility() {
            gridVisible = !gridVisible;
            scene.children.forEach(child => {
                if (child instanceof THREE.GridHelper) {
                    child.visible = gridVisible;
                }
            });
        }

        // Show main menu
        function showMainMenu() {
            document.getElementById('mainMenu').classList.add('show');
        }

        // Hide main menu
        function hideMainMenu() {
            document.getElementById('mainMenu').classList.remove('show');
        }

        // Show save modal
        function showSaveModal() {
            document.getElementById('saveModal').classList.add('show');
            hideMainMenu();
        }

        // Hide save modal
        function hideSaveModal() {
            document.getElementById('saveModal').classList.remove('show');
        }

        // Show export modal
        function showExportModal(type) {
            const exportModal = document.getElementById('exportModal');
            const formatSelect = document.getElementById('exportFormat');
            
            // Set options based on export type
            if (type === 'image') {
                formatSelect.innerHTML = `
                    <option value="png">PNG Image</option>
                    <option value="jpg">JPG Image</option>
                `;
            } else {
                formatSelect.innerHTML = `
                    <option value="obj">OBJ 3D Model</option>
                    <option value="stl">STL 3D Model</option>
                `;
            }
            
            exportModal.classList.add('show');
            hideMainMenu();
        }

        // Hide export modal
        function hideExportModal() {
            document.getElementById('exportModal').classList.remove('show');
        }

        // Create new project
        function newProject() {
            if (confirm('Are you sure you want to start a new project? All unsaved changes will be lost.')) {
                // Remove all objects
                objects.forEach(obj => {
                    scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(m => m.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                });
                
                objects = [];
                selectedObjects = [];
                hideMainMenu();
            }
        }

        // Save project
        function saveProject() {
            const projectName = document.getElementById('projectName').value.trim();
            
            if (!projectName) {
                alert('Please enter a project name');
                return;
            }
            
            // Serialize the scene
            const projectData = {
                name: projectName,
                date: new Date().toISOString(),
                objects: objects.map(obj => serializeObject(obj))
            };
            
            // Save to localStorage
            let projects = JSON.parse(localStorage.getItem('kaarigar3d_projects') || '[]');
            
            // Check if project with this name already exists
            const existingIndex = projects.findIndex(p => p.name === projectName);
            if (existingIndex >= 0) {
                projects[existingIndex] = projectData;
            } else {
                projects.push(projectData);
            }
            
            localStorage.setItem('kaarigar3d_projects', JSON.stringify(projects));
            
            alert(`Project "${projectName}" saved successfully!`);
            hideSaveModal();
            loadProjectList();
        }

        // Serialize an object for saving
        function serializeObject(obj) {
            const data = {
                type: obj.type,
                position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
                rotation: { x: obj.rotation.x, y: obj.rotation.y, z: obj.rotation.z },
                scale: { x: obj.scale.x, y: obj.scale.y, z: obj.scale.z },
                userData: obj.userData
            };
            
            if (obj instanceof THREE.Mesh || obj instanceof THREE.Line) {
                data.geometry = obj.geometry.parameters;
                
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        data.material = obj.material.map(m => ({ 
                            color: m.color.getHex(),
                            transparent: m.transparent,
                            opacity: m.opacity
                        }));
                    } else {
                        data.material = { 
                            color: obj.material.color.getHex(),
                            transparent: obj.material.transparent,
                            opacity: obj.material.opacity
                        };
                    }
                }
            }
            
            if (obj instanceof THREE.Group) {
                data.children = obj.children.map(child => serializeObject(child));
            }
            
            return data;
        }

        // Load project list
        function loadProjectList() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            
            const projects = JSON.parse(localStorage.getItem('kaarigar3d_projects') || '[]');
            
            if (projects.length === 0) {
                projectList.innerHTML = '<div class="project-item">No saved projects found</div>';
                return;
            }
            
            projects.forEach(project => {
                const item = document.createElement('div');
                item.className = 'project-item';
                item.innerHTML = `
                    <strong>${project.name}</strong>
                    <small>${new Date(project.date).toLocaleString()}</small>
                `;
                
                item.addEventListener('click', () => loadProject(project));
                projectList.appendChild(item);
            });
        }

        // Load a project
        function loadProject(projectData) {
            // Clear current scene
            newProject();
            
            // Deserialize objects
            projectData.objects.forEach(objData => {
                const obj = deserializeObject(objData);
                if (obj) {
                    scene.add(obj);
                    objects.push(obj);
                }
            });
            
            hideLoadModal();
            alert(`Project "${projectData.name}" loaded successfully!`);
        }

        // Deserialize an object from saved data
        function deserializeObject(data) {
            let obj;
            
            switch (data.type) {
                case 'Mesh':
                    let geometry, material;
                    
                    // Create geometry based on parameters
                    if (data.geometry.type === 'BoxGeometry') {
                        geometry = new THREE.BoxGeometry(
                            data.geometry.width,
                            data.geometry.height,
                            data.geometry.depth
                        );
                    } else if (data.geometry.type === 'PlaneGeometry') {
                        geometry = new THREE.PlaneGeometry(
                            data.geometry.width,
                            data.geometry.height
                        );
                    } else if (data.geometry.type === 'CircleGeometry') {
                        geometry = new THREE.CircleGeometry(
                            data.geometry.radius,
                            data.geometry.segments
                        );
                    } else if (data.geometry.type === 'ShapeGeometry') {
                        // Simplified - in real app we'd reconstruct the shape
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                    }
                    
                    // Create material
                    if (data.material) {
                        if (Array.isArray(data.material)) {
                            material = data.material.map(m => new THREE.MeshBasicMaterial({ 
                                color: new THREE.Color(m.color),
                                transparent: m.transparent,
                                opacity: m.opacity
                            }));
                        } else {
                            material = new THREE.MeshBasicMaterial({ 
                                color: new THREE.Color(data.material.color),
                                transparent: data.material.transparent,
                                opacity: data.material.opacity
                            });
                        }
                    }
                    
                    obj = new THREE.Mesh(geometry, material);
                    break;
                    
                case 'Line':
                    // Simplified line deserialization
                    const lineGeometry = new THREE.BufferGeometry();
                    const lineMaterial = new THREE.LineBasicMaterial({ color: data.material.color });
                    obj = new THREE.Line(lineGeometry, lineMaterial);
                    break;
                    
                case 'Group':
                    obj = new THREE.Group();
                    
                    if (data.children) {
                        data.children.forEach(childData => {
                            const child = deserializeObject(childData);
                            if (child) obj.add(child);
                        });
                    }
                    break;
            }
            
            if (obj) {
                // Set position, rotation, scale
                obj.position.set(data.position.x, data.position.y, data.position.z);
                obj.rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
                obj.scale.set(data.scale.x, data.scale.y, data.scale.z);
                
                // Copy user data
                obj.userData = data.userData || {};
            }
            
            return obj;
        }

        // Export project
        function exportProject() {
            const format = document.getElementById('exportFormat').value;
            
            if (format === 'png' || format === 'jpg') {
                exportAsImage(format);
            } else if (format === 'obj' || format === 'stl') {
                exportAs3DModel(format);
            }
            
            hideExportModal();
        }

        // Export as image
        function exportAsImage(format) {
            // Temporarily hide UI elements
            const toolbar = document.getElementById('mainToolbar');
            toolbar.style.visibility = 'hidden';
            
            // Render the scene to a data URL
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL(`image/${format}`);
            
            // Create download link
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = `kaarigar3d_export_${new Date().toISOString().slice(0, 10)}.${format}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Restore UI elements
            toolbar.style.visibility = 'visible';
        }

        // Export as 3D model
        function exportAs3DModel(format) {
            // Combine all objects into a single group for export
            const exportGroup = new THREE.Group();
            objects.forEach(obj => {
                exportGroup.add(obj.clone());
            });
            
            let exporter, fileExtension;
            
            if (format === 'obj') {
                exporter = new THREE.OBJExporter();
                fileExtension = 'obj';
            } else {
                exporter = new THREE.STLExporter();
                fileExtension = 'stl';
            }
            
            const result = exporter.parse(exportGroup);
            
            // Create download link
            const blob = new Blob([result], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `kaarigar3d_export_${new Date().toISOString().slice(0, 10)}.${fileExtension}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Get normalized mouse coordinates
        function getNormalizedMouseCoordinates(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            return {
                x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
                y: -((event.clientY - rect.top) / rect.height) * 2 + 1
            };
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
